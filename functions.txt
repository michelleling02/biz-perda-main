âœ… Functions to Keep (No Changes Needed)
These functions are already well-defined and do not conflict with the new architecture.
check_and_create_milestone_notifications
create_user_profile_and_role
get_all_approved_shops_with_details
get_customer_profile_stats
get_daily_engagement_stats
get_owner_profile_stats
get_owner_shops_with_stats
get_shop_details_with_relations
search_shops_by_link
update_shops_fts
âœï¸ Functions to Fix
These functions are essential but contain outdated logic (like using UUIDs) that needs to be corrected.
create_shop_with_links: Still uses auth.uid() without casting to text.
get_daily_view_stats: Still uses UUID for the p_owner_id parameter.
get_owner_analytics_overview: Still uses UUID for the p_owner_id parameter.
get_single_shop_details: Needs to be updated to use the corrected views.
is_admin: The logic is flawed because it references a role_id that doesn't exist in your userroles table.
search_shops: Returns shop_id as a UUID, which should be TEXT.
update_shop_links: The authorization check compares a UUID to TEXT.
âŒ Functions to Delete
These functions are either redundant, part of the old (and now incorrect) auth.users trigger system, or are simply obsolete. They cause conflicts and must be removed.
assign_user_roles: Redundant. This logic is correctly handled by create_user_profile_and_role.
create_profile_for_user: Obsolete. This is from the old trigger system. Your app should only call create_user_profile_and_role.
get_owner_dashboard_kpis: Redundant. The get_owner_profile_stats function provides the same data.
get_owner_engagement_chart: Redundant. This is a duplicate of get_daily_engagement_stats.
get_owner_shop_views_chart: Redundant. This is a duplicate of get_daily_view_stats.
is_owner: The logic is flawed and this check is better handled directly in RLS policies.
log_shop_view (both versions): Both are flawed. We will replace them with a single, correct version.

assign_user_roles
BEGIN
  INSERT INTO user_roles (user_id, role)
  VALUES (p_user_id, p_role);
END;

check_and_create_milestone_notifications
DECLARE
    shop_stat RECORD;
    milestone_views INT[] := ARRAY[100, 500, 1000, 5000, 10000];
    milestone_favs INT[] := ARRAY[10, 50, 100, 250, 500];
    m_value INT;
BEGIN
    -- Loop through every shop's performance stats
    -- === THIS IS THE FIX: JOIN with the shops table to get the name ===
    FOR shop_stat IN
        SELECT
            sps.shop_id,
            sps.owner_user_id,
            s.name, -- Now we get the name from the shops table
            sps.total_views,
            sps.total_favorites
        FROM
            public.shop_performance_stats sps
        JOIN
            public.shops s ON sps.shop_id = s.shop_id
        WHERE
            sps.owner_user_id IS NOT NULL
    LOOP
        -- The rest of the function logic remains the same, as it now has access to shop_stat.name
        
        -- Check for view milestones
        FOREACH m_value IN ARRAY milestone_views
        LOOP
            IF shop_stat.total_views >= m_value THEN
                IF NOT EXISTS (SELECT 1 FROM public.shopmilestones WHERE shop_id = shop_stat.shop_id AND milestone_type = 'views' AND milestone_value = m_value) THEN
                    INSERT INTO public.notifications (recipient_user_id, title, message)
                    VALUES (shop_stat.owner_user_id, 'ðŸŽ‰ Milestone Reached!', 'Congratulations! Your shop "' || shop_stat.name || '" has reached ' || m_value || ' total views!');

                    INSERT INTO public.shopmilestones (shop_id, milestone_type, milestone_value)
                    VALUES (shop_stat.shop_id, 'views', m_value);
                END IF;
            END IF;
        END LOOP;

        -- Check for favorite milestones
        FOREACH m_value IN ARRAY milestone_favs
        LOOP
            IF shop_stat.total_favorites >= m_value THEN
                IF NOT EXISTS (SELECT 1 FROM public.shopmilestones WHERE shop_id = shop_stat.shop_id AND milestone_type = 'favorites' AND milestone_value = m_value) THEN
                    INSERT INTO public.notifications (recipient_user_id, title, message)
                    VALUES (shop_stat.owner_user_id, 'ðŸ’– Milestone Reached!', 'Congratulations! Your shop "' || shop_stat.name || '" has been favorited ' || m_value || ' times!');

                    INSERT INTO public.shopmilestones (shop_id, milestone_type, milestone_value)
                    VALUES (shop_stat.shop_id, 'favorites', m_value);
                END IF;
            END IF;
        END LOOP;
    END LOOP;
END;

create_profile_for_user
DECLARE
  clerk_id TEXT;
  clerk_name TEXT;
  clerk_phone TEXT;
BEGIN
  -- Get the user ID and metadata from the JWT
  clerk_id := requesting_user_id();

  -- If there is no user ID in the token, do nothing.
  IF clerk_id IS NULL THEN
    RETURN;
  END IF;

  -- Check if the profile already exists
  IF NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = clerk_id) THEN
    -- If it does not exist, get the metadata and insert.
    clerk_name := current_setting('request.jwt.claims', true)::jsonb->'unsafe_metadata'->>'fullName';
    clerk_phone := current_setting('request.jwt.claims', true)::jsonb->'unsafe_metadata'->>'phoneNumber';

    INSERT INTO public.profiles (id, name, phone_number, profile_photo_url)
    VALUES (
      clerk_id,
      COALESCE(clerk_name, 'New User'),
      clerk_phone,
      avatar_url -- Use the URL passed as an argument
    );
  END IF;
END;

create_shop_with_links
CREATE OR REPLACE FUNCTION public.create_shop_with_links(p_name text, p_description text, p_address text, p_phone_number text, p_operating_hours text, p_latitude double precision, p_longitude double precision, p_category_ids integer[], p_tag_ids integer[])
RETURNS bigint LANGUAGE plpgsql AS $$
DECLARE
    new_shop_id BIGINT;
BEGIN
    INSERT INTO public.shops (name, description, address, phone_number, operating_hours, location, owner_user_id, status)
    VALUES (p_name, p_description, p_address, p_phone_number, p_operating_hours, ST_MakePoint(p_longitude, p_latitude)::geography, auth.uid()::text, 'Pending')
    RETURNING shop_id INTO new_shop_id;

    IF array_length(p_category_ids, 1) > 0 THEN
        INSERT INTO public.shopcategorylink (shop_id, category_id)
        SELECT new_shop_id, unnest(p_category_ids);
    END IF;

    IF array_length(p_tag_ids, 1) > 0 THEN
        INSERT INTO public.shoptaglink (shop_id, tag_id)
        SELECT new_shop_id, unnest(p_tag_ids);
    END IF;

    RETURN new_shop_id;
END;
$$;

create_user_profile_and_role
-- This script replaces the user creation function with the final, correct version.

CREATE OR REPLACE FUNCTION public.create_user_profile_and_role(
  p_user_id text,
  p_full_name text,
  p_email text,
  p_avatar_url text,
  p_role_name text DEFAULT 'Customer' -- The app will pass 'Customer' or 'Owner'
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER AS $$
DECLARE
  v_role_id bigint; -- Variable to hold the numeric role ID
BEGIN
  -- Step 1: Look up the role_id from the roles table based on the name provided.
  SELECT role_id INTO v_role_id FROM public.roles WHERE role_name = p_role_name;

  -- Step 2: If no role was found, raise an error.
  IF v_role_id IS NULL THEN
    RAISE EXCEPTION 'Invalid role name provided: %', p_role_name;
  END IF;

  -- Step 3: Insert into the profiles table (this part was already correct).
  INSERT INTO public.profiles (id, name, email, profile_photo_url)
  VALUES (p_user_id, p_full_name, p_email, p_avatar_url);

  -- Step 4: Insert into the user_roles table using the numeric v_role_id we found.
  INSERT INTO public.userroles (user_id, role_id)
  VALUES (p_user_id, v_role_id);
END;
$$;

get_all_approved_shops_with_details
    SELECT
        s.shop_id,
        s.name,
        s.description,
        -- Get the main photo URL
        (SELECT sp.photo_url FROM public.shopphotos sp WHERE sp.shop_id = s.shop_id AND sp.type = 'Main' LIMIT 1) AS main_photo_path,
        -- Convert location to text
        ST_AsText(s.location) AS location_text,
        -- Calculate average rating, handling cases with no reviews (returns 0)
        COALESCE((SELECT AVG(r.rating) FROM public.reviews r WHERE r.shop_id = s.shop_id), 0) AS avg_rating,
        -- Count reviews
        (SELECT COUNT(*) FROM public.reviews r WHERE r.shop_id = s.shop_id) AS review_count,
        -- Aggregate category names into an array
        COALESCE(array_agg(DISTINCT c.name) FILTER (WHERE c.name IS NOT NULL), '{}') AS categories,
        -- Aggregate tag names into an array
        COALESCE(array_agg(DISTINCT t.tag_name) FILTER (WHERE t.tag_name IS NOT NULL), '{}') AS tags
    FROM
        public.shops s
    LEFT JOIN
        public.shopcategorylink scl ON s.shop_id = scl.shop_id
    LEFT JOIN
        public.categories c ON scl.category_id = c.category_id
    LEFT JOIN
        public.shoptaglink stl ON s.shop_id = stl.shop_id
    LEFT JOIN
        public.tags t ON stl.tag_id = t.tag_id
    WHERE
        s.status = 'Approved'
    GROUP BY
        s.shop_id;

get_customer_profile_stats
  SELECT
    (SELECT COUNT(*) FROM shopfavourites WHERE user_id = p_customer_id) AS total_favorites,
    (SELECT COUNT(*) FROM reviews WHERE user_id = p_customer_id) AS total_reviews,
    (SELECT COUNT(DISTINCT shop_id) FROM shopviews WHERE user_id = p_customer_id) AS total_visited;

get_daily_engagement_stats
BEGIN
    RETURN QUERY
    SELECT
        to_char(d.period_start, 'YYYY-MM-DD') AS period_label,
        COUNT(DISTINCT sv.view_id) AS total_views,
        COUNT(DISTINCT sf.user_id) AS total_favorites,
        COUNT(DISTINCT r.review_id) AS total_reviews
    FROM
        generate_series(p_start_date, p_end_date, '1 day'::interval) AS d(period_start)
    LEFT JOIN shops s ON s.owner_user_id = p_owner_id
    LEFT JOIN shopviews sv ON sv.shop_id = s.shop_id AND sv.viewed_at::date = d.period_start
    LEFT JOIN shopfavourites sf ON sf.shop_id = s.shop_id AND sf.created_at::date = d.period_start
    LEFT JOIN reviews r ON r.shop_id = s.shop_id AND r.created_at::date = d.period_start
    GROUP BY d.period_start
    ORDER BY d.period_start;
END;

get_daily_engagement_stats (still using UUID)
BEGIN
    RETURN QUERY
    WITH date_series AS (
        SELECT generate_series(
            date_trunc(p_group_by_period, p_start_date),
            p_end_date,
            ('1 ' || p_group_by_period)::interval
        )::date AS period_start
    ),
    engagement_data AS (
        -- This part for reviews is correct
        SELECT r.created_at::date AS event_date, 'review' AS type FROM public.reviews r JOIN public.shops s ON r.shop_id = s.shop_id WHERE s.owner_user_id = p_owner_id AND r.created_at::date BETWEEN p_start_date AND p_end_date
        
        UNION ALL
        
        -- === THIS IS THE ONLY CHANGE THAT MATTERS ===
        -- The table name is corrected to 'shopfavourites' (WITH a 'u')
        SELECT sf.created_at::date, 'favorite' FROM public.shopfavourites sf JOIN public.shops s ON sf.shop_id = s.shop_id WHERE s.owner_user_id = p_owner_id AND sf.created_at::date BETWEEN p_start_date AND p_end_date
        
        UNION ALL
        
        -- This part for views is correct
        SELECT sv.viewed_at::date, 'view' FROM public.shopviews sv JOIN public.shops s ON sv.shop_id = s.shop_id WHERE s.owner_user_id = p_owner_id AND sv.viewed_at::date BETWEEN p_start_date AND p_end_date
    )
    SELECT
        CASE
            WHEN p_group_by_period = 'day' THEN to_char(ds.period_start, 'Dy')
            WHEN p_group_by_period = 'week' THEN 'W' || to_char(ds.period_start, 'WW')
            WHEN p_group_by_period = 'month' THEN to_char(ds.period_start, 'Mon')
            ELSE to_char(ds.period_start, 'Dy')
        END AS period_label,
        COUNT(ed.type) FILTER (WHERE ed.type = 'view') AS total_views,
        COUNT(ed.type) FILTER (WHERE ed.type = 'favorite') AS total_favorites,
        COUNT(ed.type) FILTER (WHERE ed.type = 'review') AS total_reviews
    FROM date_series ds
    LEFT JOIN engagement_data ed ON ed.event_date >= ds.period_start AND ed.event_date < (ds.period_start + ('1 ' || p_group_by_period)::interval)
    GROUP BY ds.period_start
    ORDER BY ds.period_start ASC;
END;

get_daily_view_stats
CREATE OR REPLACE FUNCTION public.get_daily_view_stats(p_owner_id text, p_start_date date, p_end_date date, p_group_by_period text)
RETURNS TABLE(view_date text, day_name text, total_views bigint)
LANGUAGE sql STABLE AS $$
    WITH date_series AS (
        SELECT generate_series(date_trunc(p_group_by_period, p_start_date), date_trunc(p_group_by_period, p_end_date), ('1 ' || p_group_by_period)::interval)::date AS period_start
    ),
    owner_shop_views AS (
        SELECT date_trunc(p_group_by_period, sv.viewed_at)::date AS view_date
        FROM public.shopviews sv JOIN public.shops s ON sv.shop_id = s.shop_id
        WHERE s.owner_user_id = p_owner_id AND sv.viewed_at::date BETWEEN p_start_date AND p_end_date
    )
    SELECT
        to_char(ds.period_start, 'YYYY-MM-DD'),
        CASE
            WHEN p_group_by_period = 'day' THEN to_char(ds.period_start, 'Dy')
            WHEN p_group_by_period = 'week' THEN 'W' || to_char(ds.period_start, 'WW')
            WHEN p_group_by_period = 'month' THEN to_char(ds.period_start, 'Mon')
            ELSE to_char(ds.period_start, 'Dy')
        END,
        COUNT(osv.view_date)
    FROM date_series ds LEFT JOIN owner_shop_views osv ON ds.period_start = osv.view_date
    GROUP BY ds.period_start ORDER BY ds.period_start ASC;
$$;

get_owner_analytics_overview (still using UUID)
CREATE OR REPLACE FUNCTION public.get_owner_analytics_overview(p_owner_id text, p_period_days integer)
RETURNS TABLE(total_views bigint, total_favorites bigint, avg_rating numeric, total_reviews bigint)
LANGUAGE sql STABLE AS $$
  SELECT COUNT(DISTINCT sv.view_id), COUNT(DISTINCT sf.user_id), AVG(r.rating), COUNT(DISTINCT r.review_id)
  FROM shops s
  LEFT JOIN shopviews sv ON s.shop_id = sv.shop_id AND sv.viewed_at >= (NOW() - (p_period_days || ' days')::interval)
  LEFT JOIN shopfavourites sf ON s.shop_id = sf.shop_id AND sf.created_at >= (NOW() - (p_period_days || ' days')::interval)
  LEFT JOIN reviews r ON s.shop_id = r.shop_id AND r.created_at >= (NOW() - (p_period_days || ' days')::interval)
  WHERE s.owner_user_id = p_owner_id;
$$;

get_owner_dashboard_kpis
BEGIN
    RETURN QUERY
    SELECT
        COALESCE(COUNT(sps.shop_id), 0),
        COALESCE(SUM(sps.total_views), 0),
        COALESCE(SUM(sps.total_favorites), 0),
        COALESCE(AVG(sps.average_rating), 0.0)
    FROM
        public.shop_performance_stats sps
    WHERE
        sps.owner_user_id = p_owner_id;
END;

get_owner_engagement_chart
BEGIN
    RETURN QUERY
    WITH date_series AS (
        SELECT generate_series(
            date_trunc(p_group_by_period, p_start_date),
            p_end_date,
            ('1 ' || p_group_by_period)::interval
        )::date AS period_start
    ),
    engagement_data AS (
        SELECT r.created_at::date AS event_date, 'review' AS type FROM public.reviews r JOIN public.shops s ON r.shop_id = s.shop_id WHERE s.owner_user_id = p_owner_id AND r.created_at::date BETWEEN p_start_date AND p_end_date
        UNION ALL
        SELECT sf.created_at::date, 'favorite' FROM public.shopfavourites sf JOIN public.shops s ON sf.shop_id = s.shop_id WHERE s.owner_user_id = p_owner_id AND sf.created_at::date BETWEEN p_start_date AND p_end_date
        UNION ALL
        SELECT sv.viewed_at::date, 'view' FROM public.shopviews sv JOIN public.shops s ON sv.shop_id = s.shop_id WHERE s.owner_user_id = p_owner_id AND sv.viewed_at::date BETWEEN p_start_date AND p_end_date
    )
    SELECT
        CASE
            WHEN p_group_by_period = 'day' THEN to_char(ds.period_start, 'Dy')
            WHEN p_group_by_period = 'week' THEN 'W' || to_char(ds.period_start, 'WW')
            WHEN p_group_by_period = 'month' THEN to_char(ds.period_start, 'Mon')
            ELSE to_char(ds.period_start, 'Dy')
        END AS period_label,
        COUNT(ed.type) FILTER (WHERE ed.type = 'view') AS total_views,
        COUNT(ed.type) FILTER (WHERE ed.type = 'favorite') AS total_favorites,
        COUNT(ed.type) FILTER (WHERE ed.type = 'review') AS total_reviews
    FROM date_series ds
    LEFT JOIN engagement_data ed ON ed.event_date >= ds.period_start AND ed.event_date < (ds.period_start + ('1 ' || p_group_by_period)::interval)
    GROUP BY ds.period_start
    ORDER BY ds.period_start ASC;
END;

get_owner_profile_stats
  SELECT
    COUNT(DISTINCT s.shop_id) AS total_shops,
    COUNT(DISTINCT v.view_id) AS total_views,
    COUNT(DISTINCT f.user_id) AS total_favorites,
    AVG(r.rating) AS avg_rating
  FROM shops s
  LEFT JOIN shopviews v ON s.shop_id = v.shop_id
  LEFT JOIN shopfavourites f ON s.shop_id = f.shop_id
  LEFT JOIN reviews r ON s.shop_id = r.shop_id
  WHERE s.owner_user_id = p_owner_id;

get_owner_profile_stats (still using UUID)
    SELECT
        -- 1. Count the number of shops the owner has in the view
        COALESCE(COUNT(sps.shop_id), 0),
        
        -- 2. Sum the total_views column for all of the owner's shops
        COALESCE(SUM(sps.total_views), 0),
        
        -- 3. Sum the total_favorites column for all of the owner's shops
        COALESCE(SUM(sps.total_favorites), 0),
        
        -- 4. Calculate the overall average rating across all of the owner's shops
        COALESCE(AVG(sps.average_rating), 0.0)
    FROM
        public.shop_performance_stats sps
    WHERE
        sps.owner_user_id = p_owner_id;

get_owner_shop_views_chart
BEGIN
    RETURN QUERY
    WITH date_series AS (
        SELECT generate_series(
            date_trunc(p_group_by_period, p_start_date),
            date_trunc(p_group_by_period, p_end_date),
            ('1 ' || p_group_by_period)::interval
        )::date AS period_start
    ),
    owner_shop_views AS (
        SELECT date_trunc(p_group_by_period, sv.viewed_at)::date AS view_date
        FROM public.shopviews sv
        JOIN public.shops s ON sv.shop_id = s.shop_id
        WHERE s.owner_user_id = p_owner_id AND sv.viewed_at::date BETWEEN p_start_date AND p_end_date
    )
    SELECT
        to_char(ds.period_start, 'YYYY-MM-DD') AS view_date,
        CASE
            WHEN p_group_by_period = 'day' THEN to_char(ds.period_start, 'Dy')
            WHEN p_group_by_period = 'week' THEN 'W' || to_char(ds.period_start, 'WW')
            WHEN p_group_by_period = 'month' THEN to_char(ds.period_start, 'Mon')
            ELSE to_char(ds.period_start, 'Dy')
        END AS day_name,
        COUNT(osv.view_date) AS total_views
    FROM date_series ds
    LEFT JOIN owner_shop_views osv ON ds.period_start = osv.view_date
    GROUP BY ds.period_start
    ORDER BY ds.period_start ASC;
END;

get_owner_shops_with_stats
  SELECT
    s.shop_id,
    s.created_at,
    s.name,
    s.description,
    s.address,
    s.operating_hours,
    s.phone_number,
    s.owner_user_id,
    s.status,
    COUNT(DISTINCT v.user_id) AS total_views,
    COUNT(DISTINCT f.user_id) AS total_favorites,
    AVG(r.rating) AS average_rating
  FROM shops s
  LEFT JOIN shopviews v ON s.shop_id = v.shop_id

get_shop_details_with_relations
    SELECT
        s.shop_id,
        s.name,
        s.description,
        s.address,
        s.phone_number,
        s.operating_hours,
        ARRAY(SELECT c.name FROM categories c JOIN shopcategorylink scl ON c.category_id = scl.category_id WHERE scl.shop_id = s.shop_id) AS categories,
        ARRAY(SELECT t.tag_name FROM tags t JOIN shoptaglink stl ON t.tag_id = stl.tag_id WHERE stl.shop_id = s.shop_id) AS tags
    FROM
        shops s
    WHERE
        s.shop_id = p_shop_id;

get_single_shop_details
CREATE OR REPLACE FUNCTION public.get_single_shop_details(p_shop_id bigint)
RETURNS TABLE(shop_id bigint, name character varying, description text, address text, phone_number text, operating_hours character varying, total_views bigint, total_favorites bigint)
LANGUAGE plpgsql STABLE AS $$
BEGIN
    RETURN QUERY
    SELECT s.shop_id, s.name, s.description, s.address, s.phone_number, s.operating_hours, sps.total_views, sps.total_favorites
    FROM public.shops s LEFT JOIN public.shop_performance_stats sps ON s.shop_id = sps.shop_id
    WHERE s.shop_id = p_shop_id;
END;
$$;

is_admin
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean LANGUAGE sql SECURITY DEFINER AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.userroles WHERE user_id = auth.uid()::text AND role_id = '3'
  );
$$;

is_owner
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.UserRoles ur
    JOIN public.Roles r ON ur.role_id = r.role_id
    WHERE ur.user_id = auth.uid() AND r.role_name = 'Owner'
  );
END;

log_shop_view
CREATE OR REPLACE FUNCTION public.log_shop_view(p_shop_id_to_log bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  INSERT INTO public.shopviews(shop_id, user_id, viewed_at)
  VALUES(p_shop_id_to_log, auth.uid()::text, NOW())
  ON CONFLICT (shop_id, user_id) DO UPDATE SET viewed_at = NOW();
END;
$$;

CREATE OR REPLACE FUNCTION public.search_shops(search_term text)
RETURNS TABLE(shop_id text, name text, description text, address text, status status, avg_rating numeric, review_count bigint, display_photo_url text)
LANGUAGE plpgsql STABLE AS $$
BEGIN
    RETURN QUERY
    WITH shop_search AS (
        SELECT s.shop_id, s.name, s.description, s.address, s.status
        FROM shops s
        WHERE s.name_desc_fts @@ plainto_tsquery('english', search_term) AND s.status = 'Approved'
    ), shop_reviews AS (
        SELECT r.shop_id, AVG(r.rating) as avg_rating, COUNT(r.rating) as review_count
        FROM reviews r WHERE r.shop_id IN (SELECT ss.shop_id FROM shop_search ss)
        GROUP BY r.shop_id
    ), shop_photos AS (
        SELECT p.shop_id, p.photo_url
        FROM shopphotos p WHERE p.shop_id IN (SELECT ss.shop_id FROM shop_search ss) AND p.type = 'Main'
    )
    SELECT ss.shop_id::text, ss.name, ss.description, ss.address, ss.status, COALESCE(sr.avg_rating, 0), COALESCE(sr.review_count, 0), sp.photo_url
    FROM shop_search ss
    LEFT JOIN shop_reviews sr ON ss.shop_id = sr.shop_id
    LEFT JOIN shop_photos sp ON ss.shop_id = sp.shop_id;
END;
$$;

search_shops_by_link
    SELECT s.*
    FROM public.shops s
    WHERE
        s.status = 'Approved'
        AND
        -- If a category ID is provided, the shop MUST be in that category.
        -- If p_category_id is NULL, this condition is true for all shops.
        (p_category_id IS NULL OR s.shop_id IN (
            SELECT scl.shop_id FROM public.shopcategorylink scl WHERE scl.category_id = p_category_id
        ))
        AND
        -- If a tag ID is provided, the shop MUST have that tag.
        -- If p_tag_id is NULL, this condition is true for all shops.
        (p_tag_id IS NULL OR s.shop_id IN (
            SELECT stl.shop_id FROM public.shoptaglink stl WHERE stl.tag_id = p_tag_id
        ));

update_shop_links
CREATE OR REPLACE FUNCTION public.update_shop_links(p_shop_id bigint, p_category_ids integer[], p_tag_ids integer[])
RETURNS void LANGUAGE plpgsql AS $$
BEGIN
    IF NOT (auth.uid()::text = (SELECT owner_user_id FROM public.shops WHERE shop_id = p_shop_id)) THEN
        RAISE EXCEPTION 'You are not authorized to edit this shop.';
    END IF;

    DELETE FROM public.shopcategorylink WHERE shop_id = p_shop_id;
    DELETE FROM public.shoptaglink WHERE shop_id = p_shop_id;

    IF array_length(p_category_ids, 1) > 0 THEN
        INSERT INTO public.shopcategorylink (shop_id, category_id)
        SELECT p_shop_id, unnest(p_category_ids);
    END IF;

    IF array_length(p_tag_ids, 1) > 0 THEN
        INSERT INTO public.shoptaglink (shop_id, tag_id)
        SELECT p_shop_id, unnest(p_tag_ids);
    END IF;
END;
$$;

update_shops_fts
BEGIN
  NEW.name_desc_fts :=
    setweight(to_tsvector('english', coalesce(NEW.name, '')), 'A') ||
    setweight(to_tsvector('english', coalesce(NEW.description, '')), 'B');
  RETURN NEW;
END;